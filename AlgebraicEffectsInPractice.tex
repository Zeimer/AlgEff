\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\usetheme{Darmstadt}

\newcommand{\eff}[2]{#1 ! \{ #2 \}}

\title{Algebraic Effects in practice (and in theory too)}
 
\author{Zeimer}
\date{8 November 2018}

\newcommand{\link}[2]{\href{#2}{\color{blue}{#1}}}

\begin{document}

\frame{\titlepage}

\frame{\tableofcontents}

\section{Referential transparency and purity}

\begin{frame}{Referential transparency in natural languages - definitions}
\begin{itemize}
	\item Referential transparency is a concept coming from \link{analytic philosophy}{https://en.wikipedia.org/wiki/Analytic_philosophy}
	\item A referent of a phrase is the thing to which that phrase refers. For example, the phrase ``The capital of Scotland'' refers to Edinburgh.
	\item A context is a part of a phrase with a hole, for example ``\_ is a beautiful city''.
	\item A context is referentially transparent when we can substitute terms with the same referent for each other without changing the meaning of the sentence.
	\item A context is referentially opaque if the above is not the case.
\end{itemize}
\end{frame}

\begin{frame}{Referential transparency in natural languages - examples}
\begin{itemize}
	\item Consider the context ``\_ is a beautiful city''.
	\item The sentences ``The capital of Scotland is a beautiful city'' and ``Edinburgh is a beautiful city'' have the same meaning. This means that this context is referentially transparent.
	\item Consider the context ``\_ has been the capital of Scotland since 1999''.
	\item The sentences ``Edinburgh has been the capital of Scotland since 1999'' and ``The capital of Scotland has been the capital of Scotland since 1999`` mean something different, so this context is referentially opaque.
	\item Thus referential opacity is a form of context dependence, a dependence on the outside world.
\end{itemize}
\end{frame}

\begin{frame}{Referential transparency in programming languages - definitions}
\begin{itemize}
	\item The concept was borrowed to programming languages, but since programmers rarely talk about contexts, it evolved and refers to functions.
	\item A function is referentially transparent iff its output depends only on its input (or equivalently: iff called many times with the same arguments it gives the same result).
	\item A programming language is referentially transparent iff all functions definable in this language are referentially transparent.
\end{itemize}
\end{frame}

\begin{frame}{Referential transparency in programming languages - examples}
\begin{itemize}
	\item Java is not referentially transparent, because a function call like \texttt{System.currentTimeMillis()} produces a different value each time.
	\item Haskell is also not referentially transparent, because of a similar problem: \texttt{unsafePerformIO getCPUTime} returns a different value each time it's called.
	\item Coq is referentially transparent - you can't get the current time nor anything like that.
	\item As we see, the lack of referential transparency in programming languages has a similar cause to that from natural languages - context dependence, which means access to some external state.
\end{itemize}
\end{frame}

\begin{frame}{Purity - definitions}
\begin{itemize}
	\item A concept related to referential transparency is purity. A function is \textbf{pure} if it has no \textbf{side effects}, which are understood as (read and/or write) access to some external state.
	\item This can be generalized a bit to expressions: an expressions is \textbf{pure} if evaluating it produces no side effects.
	\item Accordingly a programming language is pure (or purely functional) if all it's functions/expressions are pure.
	\item Note: sometimes the definition is expanded so that nontermination is considered impure.
\end{itemize}
\end{frame}

\begin{frame}{Purity - examples}
\begin{itemize}
	\item Since purity implies referential transparency, neither Java nor Haskell are pure.
	\item But Coq is pure - this is because it's a theorem prover meant for doing mathematics. Yes, you can't do any IO in it, but you can prove theorems! It's also pure in the stronger sense that it doesn't allow nontermination - thus it's not Turing complete.
\end{itemize}
\end{frame}

\section{Doing and being}

\begin{frame}{Not all languages are the same}
\begin{itemize}
	\item Both referential transparency and purity are very strong properties for a language to posses. Since barely any languages have them (except Coq, of course), it is more useful to consider languages more or less referentially transparent/pure depending on what they enforce and encourage.
	\item In Haskell it's easier to write referentially transparent functions. It is encouraged, it is enforced by the type system and getting around it requires some hackery. Therefore we can say that Haskell is more referentially transparent than Java.
	\item The same goes for purity - in Java even the simplest ``Hello world'' program is impure. In Haskell, in contrast, most of the IO is pure (why and how we will learn soon). Therefore, Haskell is more pure than Java.
\end{itemize}
\end{frame}

\begin{frame}{Why bother?}
\begin{itemize}
	\item Why should we care about about referential transparency and purity?
	\item They allow for certain optimizations.
	\item Enforcing them prevents some silly mistakes.
	\item They facilitate reasoning, especially equational reasoning.
	\item They are compositional, which allows decomposing big architectures into simple components.
	\item Therefore it would be a good idea to have some conceptual, formal and technological tool to make referential transparency and purity easier.
\end{itemize}
\end{frame}

\begin{frame}{Values and computations - do be do be do}
\begin{itemize}
	\item This suggests dividing (at least conceptually) all stuff out there into values and computations.
	\item A \textbf{value} is something that just is there. Value is being (like $2$) or being-to-be (like $2+2$).
	\item A \textbf{computation} is a process that does something. Computation is doing (like an evil robot punching you in the face).
\end{itemize}
\end{frame}

\begin{frame}{Referential transparency and purity for free}
\begin{itemize}
	\item Now here's the trick to get free referential transparency and purity: reification.
	\item Instead of doing something (performing a computation), we can create an object (a value) which tells us how to perform that computation.
	\item Instead of performing many computations, we can put together the objects that represent them.
	\item In the meantime we can mess with these objects, change them and interpret/transform them into something else without introducing any impurity/opacity.
	\item Finally, we can put that big object representing all our (remaining) impure computations into a single point of contact with the outside world (usually the \texttt{main} function).
\end{itemize}
\end{frame}

\begin{frame}{Value or computation?}
\begin{itemize}
	\item Consider the type $E \to A$.
	\item We can consider elements of this type to be values. They are pure functions, after all.
	\item We can, however, also see them as effectful computations of type $A$ that depend on some external environment $E$.
	\item Which point of view is better is ad hoc. Not many people consider pure functions $E \to A$ effectful, and not many people consider $IO\ a$ pure in Haskell.
\end{itemize}
\end{frame}

\begin{frame}{Examples of effects}
\begin{itemize}
	\item Nondeterminism and randomness
	\item Mutable state, reading configuration and logging
	\item Exceptions, partiality and errors
	\item Continuations - callCC, shift, reset and whatnot
	\item Input and output
	\item Nontermination
	\item Allocating memory
	\item Threads
	\item Asynchronicity
\end{itemize}
\end{frame}

\begin{frame}{The same effect or different?}
\begin{itemize}
	\item Consider the effect of performing some input/output operations.
	\item Many things qualify - reading and writing to standard input/output, manipulating files, connecting to a local network or the Internet, manipulating SQL/NoSQL database, running a HTTP server, reading data from microphone, camera, joystick, network card...
	\item Should these be considered different effects or parts of the IO effect?
	\item If your language is too weak, then they are the same.
	\item If your language is strong enough, you may consider them the same or different depending on what you need (e.g. security or ease of implementation).
\end{itemize}
\end{frame}

\begin{frame}{An effect or not?}
\begin{itemize}
	\item Consider an operation \texttt{sleep(time)}. Can calling it be regarded as an effectful behaviour?
\end{itemize}
\end{frame}


\begin{frame}{Where do effects come from?}
\begin{itemize}
	\item What effects are available in a language depends on the design (semantics) of that language.
	\item In theory, any Turing-complete language can express any effect (by implementing a compiler or interpreter of a language which supports these effects).
	\item In practice, some languages can express more effects than others or they can do it more naturally/easily.
\end{itemize}
\end{frame}

\begin{frame}{Where do effects come from: Java}
\begin{itemize}
	\item Nontermination: unrestricted while loop.
	\item Input and output: library functions for performing IO.
	\item Partiality: objects of any class can be null.
	\item Exceptions: built-in exceptions mechanism.
	\item Mutable state: assignment.
	\item Randomness: implementable (impure pseudorandom generators).
\end{itemize}
\end{frame}

\begin{frame}{Where do effects come from: Haskell}
\begin{itemize}
	\item Nontermination: unrestricted recursive calls.
	\item Input and output: built-in IO type and functions for using it.
	\item Partiality: can be implemented using algebraic data types (the type Maybe).
	\item Exceptions: the \texttt{error} function (note that this is something different than in Java). Java styled exceptions can be implemented using continuations.
	\item Mutable state: can be implemented as a monad with the type $s \to (a, s)$
	\item Randomness: implementable using pure pseudorandom generators.
\end{itemize}
\end{frame}

\begin{frame}{Where do effects come from: Coq}
\begin{itemize}
	\item Coq is a theorem prover and pure, total function programming language: \href{https://coq.inria.fr/}{https://coq.inria.fr/}
	\item Nontermination: impossible because only structural recursion is allowed.
	\item Input and output: impossible (no built-in IO).
	\item Exceptions: no Java style exceptions, but can be simulated using continuations.
	\item Partiality, mutable state, randomness: can be implemented like in Haskell.
\end{itemize}
\end{frame}

\begin{frame}{What you can and must express}
\begin{itemize}
	\item Types can be used to tell what effects a computation can have.
	\item In practice, types can tell us more (Haskell) or less (Java) and this is very useful.
	\item In theory, however, in different languages the same types (like 32-bit integers) can mean different things depending on what effects are available.
	\item Let's write $\eff{A}{e_1, \dots, e_n}$ for a computation which returns a value of type $A$ and can have effects $e_1, \dots, e_n$.
\end{itemize}
\end{frame}

\begin{frame}{The meaning of types: Java}
\begin{itemize}
	\item The meaning of a function $A \to B$ where $B$ is a primitive type can be seen as $A \to \eff{B}{\bot, \text{IO}, \text{Unchecked}, \dots}$, because this function may loop, perform IO, throw unchecked exceptions. The three dots signify that it can do even more, i. e. return a random value. But we know that it can't return null or a list of $B$s.
	\item If $B$ is not a primitive type, then $A \to B$ means $A \to \eff{B}{\bot, \text{IO}, \text{Unchecked}, \text{Null}, \dots}$ - now the result can be null.
	\item If there's a checked exception $E$ in the signature of the function, then the type $A \to B$ can be interpreted as $A \to \eff{B}{\bot, \text{IO}, \text{Unchecked}, \text{Null}, E, \dots}$, where $E$ signifies an effect of throwing the checked exception.
\end{itemize}
\end{frame}

\begin{frame}{The meaning of types: Haskell}
\begin{itemize}
	\item Surprisingly, Haskell is not very far from Java.
	\item A Haskell function of type $A \to B$ can be interpreted as $A \to \eff{B}{\bot, \text{IO}, \text{Error}, \dots}$, because it may loop, perform IO (through functions like \texttt{unsafePerformIO}), result in an error (like when calling \texttt{head} on an empty list) and many more (because we can do a lot with unsafe IO).
	\item A function of type $A \to M(B)$, where $M$ is some monad, can be interpreted as $A \to \eff{B}{\bot, \text{IO}, \text{Error}, M, \dots}$, where $M$ signifies the effect of this monad (e.g. nondeterminism for the list monad).
\end{itemize}
\end{frame}

\begin{frame}{The meaning of types: Coq}
\begin{itemize}
	\item Coq is different (otherwise I wouldn't have included it in the examples).
	\item A Coq function of type $A \to B$ means $A \to \eff{B}{}$, because it can't have any effect - it must terminate, can't perform IO or exceptions, can't return null etc.
	\item A function of type $A \to M(B)$ for some monad $M$ means $A \to \eff{B}{M}$.
\end{itemize}
\end{frame}

\begin{frame}{How effects are managed: Java}
\begin{itemize}
	\item Nontermination: you can't do anything about it.
	\item Partiality: null checks everywhere.
	\item Exceptions: \texttt{throw}, \texttt{catch}, \texttt{finally}. Checked exceptions appear in function signatures.
	\item Other effects: because Java is not very effect-aware, you can only manage them ad hoc by using them wisely.
\end{itemize}
\end{frame}

\begin{frame}{How effects are handled: Haskell}
\begin{itemize}
	\item Nontermination: you can't do anything about it.
	\item Input and output: the IO monad, but you can't do anything when it's done through \texttt{unsafePerformIO}.
	\item Exceptions (the \texttt{error} function): this can be caught, but it's a bad idea. Better avoid this effect.
	\item Other effects: monads (and applicatives too).
\end{itemize}
\end{frame}

\begin{frame}{How effects are handled: Coq}
\begin{itemize}
	\item The only effects you have come from monads/applicatives, so you use these to handle them.
\end{itemize}
\end{frame}


\begin{frame}{}
\begin{itemize}
	\item
\end{itemize}
\end{frame}

\begin{frame}{Bibliography}
\begin{itemize}
	\item \link{Referential transparency}{https://stackoverflow.com/questions/210835/what-is-referential-transparency}{https://stackoverflow.com/questions/210835/what-is-referential-transparency}
\end{itemize}
\end{frame}

\end{document}